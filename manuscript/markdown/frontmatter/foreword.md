## Foreword

There are many ways to write books about Architecture. One might attempt to catalogue a broad variety of problems and their solutions, at scales ranging from designing communities down to items of furniture, as Christopher Alexander did in [A Pattern Language][apl]:

[![A Pattern Language](images/apatternlanguage.jpg)][apl]

[apl]: http://www.amazon.com/gp/product/0195019199/ref=as_li_ss_tl?ie=UTF8&camp=1789&creative=390957&creativeASIN=0195019199&linkCode=as2&tag=raganwald001-20

### New Treehouses of the World

One might also pick a particular domain and then survey how different architects approached solving a common set of problems, highlighting the variety of possible styles. [New Treehouses of the World][th] takes this approach:

[![New Treehouses of the World](images/newtreehousesoftheworld.jpg)][th]

[th]: http://www.amazon.com/gp/product/0810996324/ref=as_li_ss_tl?ie=UTF8&camp=1789&creative=390957&creativeASIN=0810996324&linkCode=as2&tag=raganwald001-20

### The Not So Big House

Or one might approach architecture from a single viewpoint, describing a highly specific and coherent style backed by personal experience, as Sarah Susanka did in [The Not So Big House][nsb]:

[![The Not So Big House](images/notsobig.jpg)][nsb]

[nsb]: http://www.amazon.com/gp/product/1600851509/ref=as_li_ss_tl?ie=UTF8&camp=1789&creative=390957&creativeASIN=1600851509&linkCode=as2&tag=raganwald001-20

### JavaScript Spessore

[JavaScript Spessore](https://leanpub.com/javascript-spessore) follows this path. This book will not attempt to dictate the "one true definition" of object-oriented programming. It will not survey and catalog the many different programming languages and libraries people have used to solve software problems with objects.

Instead, JavaScript Spessore describes one way to design programs with objects as the central idea: Building software on top of a metaobject protocol. A metaobject protocol is a kind of abstraction for implementing object-oriented programming semantics. One program might be developed with pattern matching for methods, another might use state machines, a third might be heavily factored into aspects.

By implementing this metaobject protocol and semantics on top of it, we gain insight into how these semantics work and how they might be applied to solving problems we encounter as software developers.