## Overriding and Specializing Methods

Many languages, including JavaScript, implement "override by default." When you assign a function to a property in a prototype, you overwrite whatever method may have been previously bound to that property in the prototype, and you override any method bound to that property higher in the prototype chain.

When that's what we want to do, we're free to resolve the methods we wish to override with `{override: 'someMethod'}` But we also have the option to extend methods with `before`, `after`, and `around`.

Up to now, we've considered resolving conflicts as a way to handle the case when two behaviours both have a method with the same name, and both methods are roughly equal in importance. This is the case when an `initialize` method conflicts. But sometimes, we have behaviour that is intended to extend another behaviour's implementation of a method.

For example, if someone has children and has a parent, then adding to their children also adds their parent's grandchildren:

~~~~~~~~
var HasChildren = encapsulate({
  initialize: function () {
    this._children = [];
    return this;
  },
  addChild: function (name) {
    this._children.push(name);
    return this;
  },
  children: function () {
    return this._children;
  }
});

var HasGrandchildren = encapsulate({
  initialize: function () {
    this._grandchildren = [];
    return this;
  },
  addGrandchild: function (name) {
    this._grandchildren.push(name);
    return this;
  },
  grandchildren: function () {
    return this._grandchildren;
  }
});

var HasParent = encapsulate({
  addParent: function (parent) {
    this._parent = parent;
    return this;
  },

  addChild: function (name) {
    this._parent.addGrandchild(name);
  }
});

var gwen = Object.create(HasGrandchildren).initialize(),
    IsParentAndChild = composeBehaviours(
      HasChildren,
      resolve(HasParent, {addChild: 'after'})
    ),
    reg = Object.create(IsParentAndChild).initialize();

reg.addParent(gwen);
reg.addChild('Clara');
reg.addChild('Thomas');

gwen.grandchildren()
  //=> [ 'Clara', 'Thomas' ]
~~~~~~~~

*TODO: First write addChild where we repeat ourselves, then write the decoration version*

The general model of children, parents and grandchildren is flawed, but for the moment let's look at what's wrong with the code for implementing the behaviour and not the behaviour itself. `HasParent.addChild` clearly makes no sense on its own, it exists to "decorate" `HasChildren.addChild`.

So we always have to write `resolve(HasParent, {addChild: 'after'})`. This is error-prone. Furthermore, there is no way to check that we actually are decorating a method that already exists. What if we forget?

Instead, let's directly write `HasParent` with the resolution "baked in:"

~~~~~~~~
var HasParent = {
  addParent: function (parent) {
    this._parent = parent;
    return this;
  },

  addChild: {after: function (name) {
    this._parent.addGrandchild(name);
  }}
}

var IsParentAndChild = composeBehaviours(HasChildren, HasParent),
    gwen = Object.create(HasGrandchildren).initialize(),
    reg = Object.create(IsParentAndChild).initialize();

reg.addParent(gwen);
reg.addChild('Clara');
reg.addChild('Thomas');

gwen.grandchildren()
  //=> [ 'Clara', 'Thomas' ]
~~~~~~~~

This version of `AddParent` does not need `resolve`. We did not do this with methods like `HasChildren` above, because they made sense on their own. But as we've written it, `HasParent` must always decorate an `addChild` method, so it makes sense to write the resolution directly into the behaviour.

Furthermore, we now have a way of checking that we are composing HasParent with behaviour that already defines `addChild`:

~~~~~~~~
var HasGrandchildrenAndParent = composeBehaviours(HasGrandchildren, HasParent)
  //=> 'addChild' is not conflicted, but was given a resolution
~~~~~~~~

This is very helpful, as it prevents us from making a mistake. Our implementation *expects* to decorate `addChild`, so it's a good thing that `composeBehaviours` detects the problem.

*TODO: write a closure checker that works on a single behaviour*

### resolving methods by name

There are other ways to "signal" that we want certain methods to decorate existing methods. Many frameworks use naming conventions. We could, for example, design things so that if we write `save`, we want a save method, but if we write `afterSave`, we want to decorate an existing `save` method:

~~~~~~~~
//////////////////////////////////////////////////
//
//////////////////////////////////////////////////

var __slice = [].slice;

function extend () {
  var consumer = arguments[0],
      providers = __slice.call(arguments, 1),
      key,
      i,
      provider;

  for (i = 0; i < providers.length; ++i) {
    provider = providers[i];
    for (key in provider) {
      if (Object.prototype.hasOwnProperty.call(provider, key)) {
        consumer[key] = provider[key];
      };
    };
  };
  return consumer;
};

var var policies = {
  overwrite: function overwrite (fn1, fn2) {
    return fn1;
  },
  discard: function discard (fn1, fn2) {
    return fn2;
  },
  before: function before (fn1, fn2) {
    return function () {
      fn1.apply(this, arguments);
      return fn2.apply(this, arguments);
    }
  },
  after: function after (fn1, fn2) {
    return function () {
      fn2.apply(this, arguments);
      return fn1.apply(this, arguments);
    }
  },
  around: function around (fn1, fn2) {
    return function () {
      var argArray = [fn2.bind(this)].concat(__slice.call(arguments, 0));
      return fn1.apply(this, argArray);
    }
  }
};

//////////////////////////////////////////////////

function resolveByName (behaviour) {
  var result = Object.create(null);

  Object.keys(behaviour).forEach(function (methodName) {
    var resolver = Object.keys(policies).reduce(function (acc, policy) {
      if (Object.keys(acc).length === 0) {
        var regex = new RegExp("^" + policy + "([A-Z])(.*)$"),
            actualMethodName;
        if (md = methodName.match(regex)) {
          actualMethodName = md[1].toLowerCase() + md[2];
          acc[actualMethodName] = {};
          acc[actualMethodName][policy] = behaviour[methodName];
        }
      }
      return acc;
    }, Object.create(null));
    if (Object.keys(resolver).length === 0) {
      result[methodName] = behaviour[methodName];
    }
    else extend(result, resolver);
  });

  return result;
}

var LogsSave = resolveByName({
  toString: undefined,

  beforeSave: function () {
    console.log("saving " + this.toString());
  }
})
  //=>
    { toString: undefined,
      save: { before: [Function] } }
~~~~~~~~

"Resolve" is a bit of a misnomer when we're writing behaviour that specializes other behaviour. We're realy *decorating* behaviour. Programmers in some communities call it "stacking" behaviour:

*TODO: Sketch of stacked behaviour.*

### aspect-oriented software development

I> In computing, Aspect-oriented software development (AOSD) is an emerging software development technology that seeks new modularizations of software systems in order to isolate secondary or supporting functions from the main program's business logic.
I>
I>--[Wikipedia](https://en.wikipedia.org/wiki/Aspect-oriented_software_development)

Every entity should have a primary responsibility. For example, an award-winning songwriter's responsibility is to manage its real-world attributes, awards and songs:

~~~~~~~~
//////////////////////////////////////////////////////////////////////
//
// repeating ourself: remove before publication
//
//////////////////////////////////////////////////////////////////////

var __slice = [].slice;

function extend () {
  var consumer = arguments[0],
      providers = __slice.call(arguments, 1),
      key,
      i,
      provider;

  for (i = 0; i < providers.length; ++i) {
    provider = providers[i];
    for (key in provider) {
      if (Object.prototype.hasOwnProperty.call(provider, key)) {
        consumer[key] = provider[key];
      };
    };
  };
  return consumer;
};

function partialProxy (baseObject, methods) {
  var proxyObject = Object.create(null);

  methods.forEach(function (methodName) {
    proxyObject[methodName] = function () {
      var result = baseObject[methodName].apply(baseObject, arguments);
      return (result === baseObject)
             ? proxyObject
             : result;
    }
  });

  return proxyObject;
}

function methodsOfType (behaviour, type) {
  var methods = [],
      methodName;

  for (methodName in behaviour) {
    if (typeof(behaviour[methodName]) === type) {
      methods.push(methodName);
    }
  };
  return methods;
}

function propertyFlags (behaviour) {
  var properties = [],
      propertyName;

  for (propertyName in behaviour) {
    if (behaviour[propertyName] === null) {
      properties.push(propertyName);
    }
  }

  return properties;
}

function methodsThatResolve (behaviour) {
  return methodsOfType(behaviour, 'object').filter(function (methodName) {
    return behaviour[methodName] != null;
  });
}

var number = 0;

function encapsulate (behaviour) {
  var safekeepingName = "__" + ++number + "__",
      definedMethods = methodsOfType(behaviour, 'function'),
      dependencies = methodsOfType(behaviour, 'undefined'),
      encapsulatedObject = {};

  function createContext (methodReceiver) {
    return partialProxy(methodReceiver, dependencies);
  }

  function getContext (methodReceiver) {
    var context = methodReceiver[safekeepingName];
    if (context == null) {
      context = createContext(methodReceiver);
      Object.defineProperty(methodReceiver, safekeepingName, {
        enumerable: false,
        writable: false,
        value: context
      });
    }
    return context;
  }

  definedMethods.forEach(function (methodName) {
    var methodBody = behaviour[methodName];

    encapsulatedObject[methodName] = function () {
      var context = getContext(this),
          result  = methodBody.apply(context, arguments);
      return (result === context) ? this : result;
    };
  });

  return encapsulatedObject;
}

var policies = {
  overwrite: function overwrite (fn1, fn2) {
    return fn1;
  },
  discard: function discard (fn1, fn2) {
    return fn2;
  },
  before: function before (fn1, fn2) {
    return function () {
      fn1.apply(this, arguments);
      return fn2.apply(this, arguments);
    }
  },
  after: function after (fn1, fn2) {
    return function () {
      fn2.apply(this, arguments);
      return fn1.apply(this, arguments);
    }
  },
  around: function around (fn1, fn2) {
    return function () {
      var argArray = [fn2.bind(this)].concat(__slice.call(arguments, 0));
      return fn1.apply(this, argArray);
    }
  }
};

// We can attach them to a behaviour with a helper function:

function resolve(behaviour, policySpecification) {
  var result = extend(Object.create(null), behaviour);

  Object.keys(policySpecification).forEach(function (methodName) {
    var policy = policySpecification[methodName],
        policyResolver;

    if (typeof(policy) ===  'string') {
      policyResolver = policies[policy];
      result[methodName] = {};
      result[methodName][policy] = behaviour[methodName];
    }
    else throw "'" + policy + "' is unsupported";
  });

  return result;
}

function allEncompasses (prototype1, prototype2) {
  if (prototype1 === null) return prototype2 === null;
  if (prototype2 === null) return true;
  if (prototype1 === prototype2) return true;
  return Object.prototype.isPrototypeOf.call(prototype2, prototype1);
}

function composeBehaviours () {
  var behaviours = __slice.call(arguments, 0),
      seed = extend(Object.create(Object.getPrototypeOf(behaviours[0])), behaviours[0]);

  behaviours[0] = seed;

  return behaviours.reduce(function (composed, behaviour) {
    var definedMethods = methodsOfType(behaviour, 'function'),
        resolutions = methodsThatResolve(behaviour),
        dependencies = methodsOfType(behaviour, 'undefined');

    if (!allEncompasses(Object.getPrototypeOf(composed), Object.getPrototypeOf(behaviour))) {
      throw "incompatible prototypes";
    }

    definedMethods.forEach(function (methodName) {
      if (composed[methodName] === void 0) { // none or a dependency
        composed[methodName] = behaviour[methodName];
      }
      else throw "'" + methodName + "' has a conflict."
    });

    dependencies.forEach(function (methodName) {
      if (composed[methodName] === void 0) { // none or a dependency
        composed[methodName] = void 0;
      }
      else if (typeof(composed[methodName]) !== 'function') {
        throw "'" + methodName + "' conflicts with entry of type '" + typeof(composed[methodName]) + "'";
      }
      // else do nothing, dependency is satisfied
    });

    resolutions.forEach(function (methodName) {
      var resolution = behaviour[methodName],
          policy = Object.keys(resolution)[0],
          resolutionPolicy = policies[policy],
          newMethod = resolution[policy],
          existingMethod;

      if (methodName in composed) {
        existingMethod = composed[methodName];
        if (typeof(existingMethod) === 'function') {
          composed[methodName] = resolutionPolicy(newMethod, existingMethod);
        }
        else throw "'" + methodName + "' is attempting to resolve a '" + typeof(existingMethod) + "'";
      }
      else throw "'" + methodName + "' is not conflicted, but was given a resolution"
    });

    return composed;
  });
}

//////////////////////////////////////////////////////////////////////

var SingsSongs = encapsulate({
  initialize: function () {
    this._songs = [];
    return this;
  },
  addSong: function (name) {
    this._songs.push(name);
    return this;
  },
  songs: function () {
    return this._songs;
  }
});

var HasAwards = encapsulate({
  initialize: function () {
    this._awards = [];
    return this;
  },
  addAward: function (name) {
    this._awards.push(name);
    return this;
  },
  awards: function () {
    return this._awards;
  }
});

var AwardWinningSongwriter = composeBehaviours(
  SingsSongs,
  resolve(HasAwards, {initialize: 'after'})
);
~~~~~~~~

Secondary responsibilities are often orthogonal concerns. Waving aside EcmaScript-6's [`Object.observe`][observe] for a moment, we could design a program that has views that are notified when models like `AwardWinningSongwriter` are changed. We would start with the basic idea that something like a view could "subscribe" to a model that is a `Subscribable`:

[observe]: http://wiki.ecmascript.org/doku.php?id=harmony:observe

~~~~~~~~
var Subscribable = encapsulate({
  initialize: function () {
    this.subscribers = [];
  },
  subscribe: function (callback) {
    this.subscribers.push(callback);
  },
  unsubscribe: function (callback) {
    this.subscribers = this.subscribers.filter( function (subscriber) {
      return subscriber !== callback;
    });
  },
  notify: function () {
    this.subscribers.forEach( function (subscriber) {
      subscriber(this);
    });
  }
});
~~~~~~~~

We can make an award-winning songwriter subscribable and fake up a view to test it:

~~~~~~~~
var sweetBabyJames = Object.create(composeBehaviours(
  AwardWinningSongwriter,
  resolve( Subscribable, {initialize: 'after'} ),
  resolveByName(
    encapsulate({
      notify: undefined,
      afterAddSong: function () { return this.notify(); },
      afterAddAward: function () { return this.notify(); }
    })
  )
)).initialize();

var SongwriterView = {
  initialize: function (model, name) {
    this.model = model;
    this.name = name;
    this.model.subscribe(this.render.bind(this));
    return this;
  },
  render: function () {
    console.log(
      this.name + " has written " +
        this.model.songs().map(function (song) { return "'" + song + "'"; }).join(", ") +
        " and has won: " +
        this.model.awards().map(function (award) { return "'" + award + "'"; }).join(", ")
    );
    return this;
  }
}

var jamesView = Object.create(SongwriterView).initialize(sweetBabyJames, 'James Taylor');

sweetBabyJames.addSong('Fire and Rain')

~~~~~~~~
