## More Encapsulation {#more-encapsulation}

Some objects have multiple responsibilities. A `Person` can be an `Author`, can `HaveChildren`, can `HaveInvestments` and so forth. Each particular responsibility can be cleanly separated into its own metaobject, and their state combined into one object with techniques like our private mixins that work with shared prototypes using [safekeeping for shared prototypes](#safekeeping-shared-prototypes).

This cleanly separates the code we write along lines of responsibility. Encapsulating the base object within a proxy reduces the surface area available for coupling by hiding all private state. But each mixin has access to all of the object's methods, and every responsibility we add swells this set of methods, increasing the surface area again.

We saw in [Encapsulation for Metaobjects](#encapsulation-for-metaobjects) that we can use proxies to prevent metaobjects from manipulating the base object's properties.

Here's our `extendWithProxy` method again, but we've extracted the logic for determining the context for method invocations into `methodContext`:

~~~~~~~~
var number = 0;

function extendWithProxy (baseObject, behaviour) {
  var safekeepingName = "__" + ++number + "__",
      methodName;

  function createContext (methodReceiver) {
    return proxy(methodReceiver);
  }

  function getContext (methodReceiver) {
    var context = methodReceiver[safekeepingName];
    if (context == null) {
      context = createContext(methodReceiver);
      Object.defineProperty(methodReceiver, safekeepingName, {
        enumerable: false,
        writable: false,
        value: context
      });
    }
    return context;
  }

  for (methodName in behaviour) {
    if (behaviour.hasOwnProperty(methodName)) {
      (function (methodName) {
        baseObject[methodName] = function () {
          var context = getContext(this),
              result = behaviour[methodName].apply(context, arguments);
          return (result === context) ? this : result;
        };
      })(methodName);
    };
  };
  return baseObject;
}
~~~~~~~~

The key line of code is `context = proxy(methodReceiver);`. This lazily attaches a proxy of the method receiver to a "hidden" property. Thereafter, every method of that behaviour invoked on the same receiver will use the same context.

Thus, the functions of a mixin do not have access to the receiver's properties. In addition, since each behaviour gets its own proxy, behaviours cannot access each other's properties either.

However, `proxy` exposes *all* of the receiver's methods to every behaviour, including methods that other behaviours add. This means that behaviours can invoke each other's methods and become interdependent.

This is almost never what we want. If we're trying to decouple behaviours from each other, we want to strictly limit the methods exposed to each behaviour. Typically, there are two cases. First, a mixin may provide completely independent behaviour: It does not rely on the base object's properties or methods.

In these examples, `HasName` and `HasCareer` are self-contained mixins. They update and queries its own private state, and do not invoke any other methods. Both use a property called `value`, but if they re both mixed into the same base object, they'll each get their own property and this each have their own `value` property:

~~~~~~~~
var HasName = {
  name: function () {
    return this.name;
  },
  setName: function (name) {
    this.name = name;
    return this;
  }
};

var HasCareer = {
  career: function () {
    return this.name;
  },
  setCareer: function (name) {
    this.name = name;
    return this;
  }
};
~~~~~~~~

In contrast, `IsSelfDescribing` is a mixin that depends on the receiver implementing both the `name()` and `career()` methods. We know this from inspecting the code, and fortunately it is a small and simple mixin:

~~~~~~~~
var IsSelfDescribing = {
  description: function () {
    return this.name() + ' is a ' + this.career();
  }
};
~~~~~~~~

If we program in this style, writing mixins that have dependencies hidden inside the code, we will introduce a lot of coupling, with mixins becoming dependent upon each other in an unstructured way.

### managing dependencies

Mixins--like `IsSelfDescribing`--that depend upon the base object or another mixin implementing methods are said to *stack* upon other mixins.

*TODO: Diagram showing `IsSelfDescribing` stacking.*

We can manage these dependencies by making dependencies explicit instead of implicit. First, we'll express the dependencies using a simple convention: If a mixin depends upon a method, it must bind `undefined` to the name of the method.

This is how we'll express this for `IsSelfDescribing`:

~~~~~~~~
var IsSelfDescribing = {
  name: undefined,
  career: undefined,

  description: function () {
    return this.name() + ' is a ' + this.career();
  }
};
~~~~~~~~

The way we'll enforce this requirement is that we will no longer provide every mixin with a proxy for all of the object;s methods. Instead, we'll only expose the methods that the mixin explicitly requires.

To do that, we'll write a `partialProxy`. It works like `proxy`, but instead of iterating over the base object's properties, it iterates over a subset we provide. We will also rewrite `extendsWithProxy` to use `partialProxy` and the declared dependencies:

~~~~~~~~
function partialProxy (baseObject, methods, optionalPrototype) {
  var proxyObject = Object.create(optionalPrototype || null);

  methods.forEach(function (methodName) {
    proxyObject[methodName] = function () {
      var result = baseObject[methodName].apply(baseObject, arguments);
      return (result === baseObject)
             ? proxyObject
             : result;
    }
  });
  return proxyObject;
}

var number = 0;

function methodsOfType (behaviour, type) {
  var methods = [],
      methodName;

  for (methodName in behaviour) {
    if (typeof(behaviour[methodName]) === type) {
      methods.push(methodName);
    }
  };
  return methods;
}

function extendWithProxy (baseObject, behaviour) {
  var safekeepingName = "__" + ++number + "__",
      definedMethods = methodsOfType(behaviour, 'function'),
      dependencies = methodsOfType(behaviour, 'undefined');

  function createContext (methodReceiver) {
    return partialProxy(methodReceiver, dependencies);
  }

  function getContext (methodReceiver) {
    var context = methodReceiver[safekeepingName];
    if (context == null) {
      context = createContext(methodReceiver);
      Object.defineProperty(methodReceiver, safekeepingName, {
        enumerable: false,
        writable: false,
        value: context
      });
    }
    return context;
  }

  definedMethods.forEach( function (methodName) {
    baseObject[methodName] = function () {
      var context = getContext(this),
          result = behaviour[methodName].apply(context, arguments);
      return (result === context) ? this : result;
    };
  });
  return baseObject;
}
~~~~~~~~

Our `createContext` function now calls `partialProxy` instead of Proxy. We can try it with `HasName`, `HasCareer`, and `IsSelfDescribing`:

~~~~~~~~
var Careerist = {};

extendWithProxy(Careerist, HasName);
extendWithProxy(Careerist, HasCareer);
extendWithProxy(Careerist, IsSelfDescribing);

var michael    = Object.create(Careerist),
    bewitched = Object.create(Careerist);

michael.setName('Michael Sam');
bewitched.setName('Samantha Stephens');

michael.setCareer('Athlete');
bewitched.setCareer('Thaumaturge');

michael.description()
  //=> 'Michael Sam is a Athlete'
bewitched.description()
  //=> 'Samantha Stephens is a Thaumaturge'
~~~~~~~~

We have the same behaviour as before, but we've required that mixins explicitly declare the methods the depend on. This helps to limit encroaching coupling.

### why this matters

To summarize, instead of every behaviour having access to all of the receiver's methods, each behaviour only has access to methods it explicitly depends on.

This helps by documenting each behaviour's dependencies and by eliminating accidental coupling between behaviours.