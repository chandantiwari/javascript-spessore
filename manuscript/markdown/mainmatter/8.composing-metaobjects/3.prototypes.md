# Safely Extending Prototypes

Although we don't emphasize it, prototypes can be chained. What happens when we attempt to mix in behaviour that conflicts with a super-prototype?

~~~~~~~~
var SingsSongs = encapsulate({
  initialize: function () {
    this._songs = [];
    return this;
  },
  addSong: function (name) {
    this._songs.push(name);
    return this;
  },
  songs: function () {
    return this._songs;
  }
});

var HasAwards = encapsulate({
  initialize: function () {
    this._awards = [];
    return this;
  },
  addAward: function (name) {
    this._awards.push(name);
    return this;
  },
  awards: function () {
    return this._awards;
  }
});

var AwardWinningSongwriter = composeBehaviours(
  SingsSongs,
  resolve(HasAwards, {initialize: 'after'})
);

var HasChildren = encapsulate({
  initialize: function () {
    this._children = [];
    return this;
  },
  addChild: function (name) {
    this._children.push(name);
    return this;
  },
  children: function () {
    return this._children;
  }
});

var SingsToChildren = Object.create(AwardWinningSongwriter);
extend(SingsToChildren, HasChildren);

var sharon = Object.create(SingsToChildren);
sharon.initialize();

sharon.addAward("Grammy for Best Children's Album")
  //=> TypeError: Cannot call method 'push' of undefined
~~~~~~~~

As we might expect, `HasChildren.initialize` is being copied into `SingsToChildren`, and that's what gets evaluated when we call `sharon.initialize()`. our `composeBehaviour` function never has a chance to resolve it. Let's try:

~~~~~~~~
var SingsToChildren = composeBehaviours(
  Object.create(AwardWinningSongwriter),
  resolve(HasChildren, {initialize: 'after'})
);

var sharon = Object.create(SingsToChildren);
sharon.initialize();

sharon.addAward("Grammy for Best Children's Album");
sharon.awards()
  //=> [ 'Grammy for Best Children\'s Album' ]
~~~~~~~~

Looking good. But then:

~~~~~~~~
AwardWinningSongwriter.isPrototypeOf(sharon)
  //=> false
~~~~~~~~

Our `composeBehaviour` function ignored the prototype and "flattened" all of the behaviour into an object that delegates to `Object.prototype`. This is not what we expect. So we'll rewrite it to respect prototypes.

Now, we can't compose multiple prototypes, JavaScript only allows a single prototype. So we'll use a simple rule:

1. The prototype of the result will be the prototype of the first behaviour;
2. Subsequent behaviour will be 'flattened.'

~~~~~~~~
function composeBehaviours () {
  var firstPrototype = Object.getPrototypeOf(arguments[0]),
      seed = Object.create(firstPrototype);

  return __slice.call(arguments, 0).reduce(function (composed, behaviour) {
    var definedMethods = methodsOfType(behaviour, 'function'),
        resolutions = methodsThatResolve(behaviour),
        dependencies = methodsOfType(behaviour, 'undefined');

    definedMethods.forEach(function (methodName) {
      if (composed[methodName] === void 0) { // none or a dependency
        composed[methodName] = behaviour[methodName];
      }
      else throw "'" + methodName + "' has a conflict."
    });

    dependencies.forEach(function (methodName) {
      if (composed[methodName] === void 0) { // none or a dependency
        composed[methodName] = void 0;
      }
      else if (typeof(composed[methodName]) !== 'function') {
        throw "'" + methodName + "' conflicts with entry of type '" + typeof(composed[methodName]) + "'";
      }
      // else do nothing, dependency is satisfied
    });

    resolutions.forEach(function (methodName) {
      var resolution = behaviour[methodName],
          policy = Object.keys(resolution)[0],
          resolutionPolicy = policies[policy],
          newMethod = resolution[policy],
          existingMethod;

      if (methodName in composed) {
        existingMethod = composed[methodName];
        if (typeof(existingMethod) === 'function') {
          composed[methodName] = resolutionPolicy(newMethod, existingMethod);
        }
        else throw "'" + methodName + "' is attempting to resolve a '" + typeof(existingMethod) + "'";
      }
      else throw "'" + methodName + "' is not conflicted, but was given a resolution"
    });

    return composed;
  }, seed);
}

var SingsToChildren = composeBehaviours(
  Object.create(AwardWinningSongwriter),
  resolve(HasChildren, {initialize: 'after'})
);

var sharon = Object.create(SingsToChildren);

AwardWinningSongwriter.isPrototypeOf(sharon)
~~~~~~~~

### overriding and specializing methods

Many languages, including JavaScript, implement "override by default." When you assign a function to a property in a prototype, you overwrite whatever method may have been previously bound to that property in the prototype, and you override any method bound to that property higher in the prototype chain.

When that's what we want to do, we're free to resolve the methods we wish to override with `{override: 'someMethod'}` But we also have the option to extend methods with `before`, `after`, and `around`.

Up to now, we've considered resolving conflicts as a way to handle the case when two behaviours both have a method with the same name, and both methods are roughly equal in importance. This is the case when an `initialize` method conflicts. But sometimes, we have behaviour that is intended to extend another behaviour's implementation of a method.

For example, if someone has children and has a parent, then adding to their children also adds their parent's grandchildren:

~~~~~~~~
var HasChildren = {
  _children: null,

  initialize: function () {
    this._children = [];
    return this;
  },
  addChild: function (name) {
    this._children.push(name);
    return this;
  },
  children: function () {
    return this._children;
  }
};

var HasGrandchildren = {
  _grandchildren: null,

  initialize: function () {
    this._grandchildren = [];
    return this;
  },
  addGrandchild: function (name) {
    this._grandchildren.push(name);
    return this;
  },
  grandchildren: function () {
    return this._grandchildren;
  }
};

var HasParent = {
  _parent: null,

  addParent: function (parent) {
    this._parent = parent;
    return this;
  },

  addChild: function (name) {
    this._parent.addGrandchild(name);
  }
}

var IsParentAndChild = Prototype(null, HasChildren, resolve(HasParent, {addChild: 'after'})),
    IsGrandparent = Prototype(null, HasGrandchildren),
    gwen = Object.create(IsGrandparent).initialize(),
    reg = Object.create(IsParentAndChild).initialize();

reg.addParent(gwen);
reg.addChild('Clara');
reg.addChild('Thomas');

gwen.grandchildren()
  //=> [ 'Clara', 'Thomas' ]
~~~~~~~~

The general concept of children, parents and grandchildren is flawed, but for the moment let's look at what's wrong with the code for implementing the behaviour and not the behaviour itself. `HasParent.addChild` clearly makes no sense on its own, it exists to "decorate" `HasChildren.addChild`.

So we always have to write `resolve(HasParent, {addChild: 'after'})`. This is error-prone. What if we forget?

Instead, let's directly write `HasParent` with the resolution "baked in:"

~~~~~~~~
var HasParent = {
  _parent: null,

  addParent: function (parent) {
    this._parent = parent;
    return this;
  },

  addChild: {after: function (name) {
    this._parent.addGrandchild(name);
  }}
}

var IsParentAndChild = Prototype(null, HasChildren, HasParent),
    IsGrandparent = Prototype(null, HasGrandchildren),
    gwen = Object.create(IsGrandparent).initialize(),
    reg = Object.create(IsParentAndChild).initialize();

reg.addParent(gwen);
reg.addChild('Clara');
reg.addChild('Thomas');

gwen.grandchildren()
  //=> [ 'Clara', 'Thomas' ]
~~~~~~~~

This version of `AddParent` does not need `resolve`. We did not do this with methods like `HasChildren` above, because they made sense on their own. But as we've written it, `HasParent` must always decorate an `addChild` method, so it makes sense to write the resolution directly into the behaviour.