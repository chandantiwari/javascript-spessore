# Safely Extending Prototypes

Although we don't emphasize it, prototypes can be chained. What happens when we attempt to mix in behaviour that conflicts with a superprototype?

~~~~~~~~
var AwardWinningSongwriter = Prototype(null,
  SingsSongs,
  resolve(HasAwards, {initialize: 'after'})
);

var HasChildren = {
  _children: null,

  initialize: function () {
    this._children = [];
    return this;
  },
  addChild: function (name) {
    this._children.push(name);
    return this;
  },
  numberOfChildren: function () {
    return this._children.length;
  }
};

var SingsToChildren = Prototype(AwardWinningSongwriter, HasChildren);
  //=> 'initialize' is conflicted.
~~~~~~~~

We're trying to chain `SingsToChildren` to `AwardWinningSongwriter`, and we're overriding `initialize` again. In ordinary JavaScript, it "just happens." You have to know about it, and you end up writing constructors like this:[^es6super]

[^es6super]: EcmaScript-6 will help a little with its [super](http://www.2ality.com/2011/11/super-references.html) keyword, but you will still be required to know that it's necessary to invoke a superprototype's method.

~~~~~~~~
var HasChildren = {
  initialize: function () {
    this._children = [];
    AwardWinningSongwriter.initialize.call(this, arguments);
    return this;
  }
  // ...
}
~~~~~~~~

This is a problem, because it forces `HasChildren` to know that it will be used to extend another prototype, and that couples it to the other prototype. Can we resolve this conflict?

~~~~~~~~
var AwardWinningSongwriter = Prototype(null,
  SingsSongs,
  resolve(HasAwards, {initialize: 'after'})
);

var HasChildren = {
  _children: null,

  initialize: function () {
    this._children = [];
    return this;
  },
  addChild: function (name) {
    this._children.push(name);
    return this;
  },
  children: function () {
    return this._children;
  }
};

var FamilySinger = Prototype(AwardWinningSongwriter, resolve(HasChildren, {initialize: 'after'})),
    maria = Object.create(FamilySinger).initialize();

var FamilySinger = Prototype(null,
  SingsSongs,
  resolve(HasAwards, {initialize: 'after'}),
  resolve(HasChildren, {initialize: 'after'})
);

var maria = Object.create(FamilySinger).initialize();

maria.addSong('My Favorite Things');
maria.addChild('Agathe')
~~~~~~~~

Yes, we can safely resolve conflicts between behaviour and superprototypes.

### overriding and specializing methods

Many languages, including JavaScript, implement "override by default." When you assign a function to a property in a prototype, you overwrite whatever method may have been previously bound to that property in the prototype, and you override any method bound to that property higher in the prototype chain.

When that's what we want to do, we're free to resolve the methods we wish to override with `{override: 'someMethod'}` But we also have the option to extend methods with `before`, `after`, and `around`.

Up to now, we've considered resolving conflicts as a way to handle the case when two behaviours both have a method with the same name, and both methods are roughly equal in importance. This is the case when an `initialize` method conflicts. But sometimes, we have behaviour that is intended to extend another behaviour's implementation of a method.

For example, if someone has children and has a parent, then adding to their children also adds their parent's grandchildren:

~~~~~~~~
var HasChildren = {
  _children: null,

  initialize: function () {
    this._children = [];
    return this;
  },
  addChild: function (name) {
    this._children.push(name);
    return this;
  },
  children: function () {
    return this._children;
  }
};

var HasGrandchildren = {
  _grandchildren: null,

  initialize: function () {
    this._grandchildren = [];
    return this;
  },
  addGrandchild: function (name) {
    this._grandchildren.push(name);
    return this;
  },
  grandchildren: function () {
    return this._grandchildren;
  }
};

var HasParent = {
  _parent: null,

  addParent: function (parent) {
    this._parent = parent;
    return this;
  },

  addChild: function (name) {
    this._parent.addGrandchild(name);
  }
}

var IsParentAndChild = Prototype(null, HasChildren, resolve(HasParent, {addChild: 'after'})),
    IsGrandparent = Prototype(null, HasGrandchildren),
    gwen = Object.create(IsGrandparent).initialize(),
    reg = Object.create(IsParentAndChild).initialize();

reg.addParent(gwen);
reg.addChild('Clara');
reg.addChild('Thomas');

gwen.grandchildren()
  //=> [ 'Clara', 'Thomas' ]
~~~~~~~~

The general concept of children, parents and grandchildren is flawed, but for the moment let's look at what's wrong with the code for implementing the behaviour and not the behaviour itself. `HasParent.addChild` clearly makes no sense on its own, it exists to "decorate" `HasChildren.addChild`.

So we always have to write `resolve(HasParent, {addChild: 'after'})`. This is error-prone. What if we forget?

Instead, let's directly write `HasParent` with the resolution "baked in:"

~~~~~~~~
var HasParent = {
  _parent: null,

  addParent: function (parent) {
    this._parent = parent;
    return this;
  },

  addChild: {after: function (name) {
    this._parent.addGrandchild(name);
  }}
}

var IsParentAndChild = Prototype(null, HasChildren, HasParent),
    IsGrandparent = Prototype(null, HasGrandchildren),
    gwen = Object.create(IsGrandparent).initialize(),
    reg = Object.create(IsParentAndChild).initialize();

reg.addParent(gwen);
reg.addChild('Clara');
reg.addChild('Thomas');

gwen.grandchildren()
  //=> [ 'Clara', 'Thomas' ]
~~~~~~~~

This version of `AddParent` does not need `resolve`. We did not do this with methods like `HasChildren` above, because they made sense on their own. But as we've written it, `HasParent` must always decorate an `addChild` method, so it makes sense to write the resolution directly into the behaviour.