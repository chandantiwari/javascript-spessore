## Structural vs. Semantic Typing {#semantic-typing}

A long-cherished principle of dynamic languages is that programs employ "Duck" or "Structural" typing. So if we write:

~~~~~~~~
function deposit (account, instrument) {
  account.dollars += instrument.dollars;
  account.cents   += instrument.cents;
  account.dollars += Math.floor(account.cents / 100);
  account.cents    = account.cents % 100;
  return account;
}
~~~~~~~~

This works for things that look like cheques, and for things that look like money orders:[^wellactually]

~~~~~~~~
cheque = {
  dollars: 100,
  cents: 0,
  number: 6
}

deposit(currentAccount, cheque);

moneyOrder = {
  dollars: 100,
  cents: 0,
  fee: 1.50
}

deposit(currentAccount, moneyOrder);
~~~~~~~~

[^wellactually]: There're good things we can say about why we should consider making an `amount` property, and/or encapsulate these structs so they behave like objects, but this gives the general idea of structural typing.

The general idea here is that as long as we pass `deposit` an `instrument` that has `dollars` and `cents` properties, the function will work. We can think about `hasDollarsAndCents` as a "type," and we can say that programming in a dynamic language like JavaScript is programming in a world where there is a many-many relationship between types and entities.

Every single entity that has `dollars` and `cents` has the imaginary type `hasDollarsAndCents`, and every single function that takes a parameter and uses only its `dollars` and `cents` properties is a function that requires a parameter of type `hasDollarsAndCents`.

There is no checking of this in advance, like some other languages, but there also isn't any explicit declaration of these types. They exist logically in the running system, but not manifestly in the code we write.

This maximizes flexibility, in that it encourages the creation of small, independent pieces work seamlessly together. It also makes it easy to refactor to small, independent pieces. The code above could easily be changed to something like this:

~~~~~~~~
cheque = {
  amount: {
    dollars: 100,
    cents: 0
  },
  number: 6
}

deposit(currentAccount, cheque.amount);

moneyOrder = {
  amount: {
    dollars: 100,
    cents: 0
  },
  fee: 1.50
}

deposit(currentAccount, moneyOrder.amount);
~~~~~~~~

### drawbacks

This flexibility has a cost. With our ridiculously simple example above, we can easy deposit new kinds of instruments. But we can also do things like this:

~~~~~~~~
var backTaxesOwed = {
  dollars: 10,874,
  cents: 06
}

var rentReceipt = {
  dollars: 420,
  cents: 0,
  unit: 504,
  month: 6,
  year: 1962
}

deposit(backTaxesOwed, rentReceipt);
~~~~~~~~

Structurally, `deposit` is compatible with any two things that `haveDollarsAndCents`. But not all things that `haveDollarsAndCents` are semantically appropriate for deposits. This is why some OO language communities work very hard developing and using type systems that incorporate semantics.

This is not just a theoretical concern. Numbers and strings are the ultimate in semantic-free data types. Confusing metric with imperial measures is thought to have caused the loss of the [Mars Climate Orbiter]. To prevent mistakes like this in software, forcing values to have compatible semantics--and not just superficially compatible structure--is thought to help create self-documenting code and to surface bugs.

[Mars Climate Orbiter]: https://en.wikipedia.org/wiki/Mars_Climate_Orbiter

### semantic structs

We've already seen [Records](#records):

~~~~~~~~
function Record (template) {
  if (Record.prototype.isPrototypeOf(this)) {
    var struct = this;

    Object.keys(template).forEach(function (key) {
      Object.defineProperty(struct, key, {
        enumerable: true,
        writable: true,
        value: template[key]
      });
    });
    return Object.preventExtensions(struct);
  }
  else return new Record(template);
}
~~~~~~~~

`Record` is a structural type, not a semantic type. But it can be extended to incorporate the notion of semantic types by turning it from and object factory into a "factory-factory." Here's `Struct`: We give it a name and the keys we want, and it gives us a JavaScript constructor function:

~~~~~~~~
function Struct () {
  var name = arguments[0],
      keys = [].slice.call(arguments, 1),
      constructor = eval("(function "+name+"(argument) { return initialize.call(this, argument); })");

  function initialize (argument) {
    var struct = this;

    keys.forEach(function (key) {
      Object.defineProperty(struct, key, {
        enumerable: true,
        writable: true,
        value: argument[key]
      });
    });
    return Object.preventExtensions(struct);
  };

  return constructor;
}

var Depositable = Struct('Depositiable', 'dollars', 'cents'),
    RecordOfPayment = Struct('RecordOfPayment', 'dollars', 'cents');

var cheque = new Depositable({dollars: 420, cents: 0});

cheque.constructor;
  //=> [Function: Depositiable]

cheque instanceof Depositable;
  //=> true
cheque instanceof RecordOfPayment;
  //=> false
~~~~~~~~

Although `Depositable` and `RecordOfPayment` have the same structural type, they are different semantic types, and we can detect the difference with `instanceof` (and `Object.isPrototypeOf`).

### using predicate dispatch with semantic types

We will upgrade `Struct` slightly, so that while `new Depositable(...)` will still make a new object, `Depositable(x)` will be a convenient shortcut for `Depositable.prototype.isPrototypeOf(x)`:

~~~~~~~~
function Struct () {
  var name = arguments[0],
      keys = [].slice.call(arguments, 1),
      constructor = eval("(function "+name+"(argument) { return initialize.call(this, argument); })");

  function initialize (argument) {
    if (constructor.prototype.isPrototypeOf(this)) {
      var argument = argument,
          struct = this;

      keys.forEach(function (key) {
        Object.defineProperty(struct, key, {
          enumerable: true,
          writable: true,
          value: argument[key]
        });
      });
      return Object.preventExtensions(struct);
    }
    else return constructor.prototype.isPrototypeOf(argument);
  };

  constructor.assertIsPrototypeOf = function (argument) {
    if (!constructor.prototype.isPrototypeOf(argument)) {
      var name = constructor.name === ''
                 ? "Struct(" + keys.join(", ") + ")"
                 : constructor.name;
      throw "Type Error: " + argument + " is not a " + name;
    }
    else return argument;
  }

  return constructor;
}
~~~~~~~~

Now, instead of:

~~~~~~~~
function deposit (account, instrument) {
  account.dollars += instrument.dollars;
  account.cents   += instrument.cents;
  account.dollars += Math.floor(account.cents / 100);
  account.cents    = account.cents % 100;
  return account;
}
~~~~~~~~

Now we can use [predicate dispatch](#predicate-dispatch), and write:

~~~~~~~~
function orElse(fn) {
  var retValue = fn.apply(this, arguments);

  return (retValue === undefined)
         ? false
         : retValue;
};

var Depositable     = Struct('Depositable', 'dollars', 'cents'),
    AcceptsDeposits = Struct('AcceptsDeposits', 'dollars', 'cents');

var deposit = Match(
  when(
    function (account, instrument) {
      return AcceptsDeposits(account) && Depositable(instrument);
    },
    function deposit (account, instrument) {
      account.dollars += instrument.dollars;
      account.cents   += instrument.cents;
      account.dollars += Math.floor(account.cents / 100);
      account.cents    = account.cents % 100;
      return account;
    }
  ),
  orElse(function () {
    throw "Illegal arguments supplied to deposit function";
  })
);
~~~~~~~~

Our new function checks its arguments or throws an exception if they don't match. And it can be expanded to handle other kinds of arguments with multiple dispatch. Later on, in [Method Dispatch](#method-dispatch), we'll see a very elegant way to express semantic type checking for arguments.

### is semantic typing worthwhile?

The value of semantic typing is an open question. There are its proponents, and its detractors. One thing to consider is the proposition that with few exceptions, a programming system cannot be improved solely by removing features that can be subject to abuse.

Instead, a system is improved by removing harmful features in such a way that they enable the addition of other, more powerful features that were "blocked" by the existence of harmful features. For example, proper or "pure" functional programming languages do not allow the mutation of values. This does remove a number of harmful possibilities, but in and of itself removing mutation is not a win.

However, once you remove mutation you enable a number of optimization techniques such as lazy evaluation. This frees programmers to do things like write code for data structures that would not be possible in languages (like JavaScript) that have an eager evaluation strategy.

Likewise, in our discussion of [encapsulating metaobjects](#encapsulation-and-composition), we introduced private state and private methods. These features take some flexibility away from programmers. But we didn't just rest on the promise of decreasing coupling: We took advantage of this to introduce a more powerful way to compose metaobjects. Reducing the "surface area" of metaobjects increases their composeability, so we ended up with more flexibility, not less.

If we subscribe to this philosophy about only reducing flexibility when it enables us to make an even greater increase in flexibility, then structural typing cannot be not be a win solely because we can "catch errors earlier" with things like using predicate dispatch to catch sementic errors. To be of benefit, it must enable some completely new kind of programming paradigm or feature that increases overall flexibility.

We'll revisit structural typing when we look at [The Expression Problem](#expresion-problem), and in particular we'll look at using structural typing to implement new dispatching protocols.