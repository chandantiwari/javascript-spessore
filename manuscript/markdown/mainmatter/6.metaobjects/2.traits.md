## Traits

Mixins, Private Mixins, Forwarding, and Delegation all work smoothly when a single template or object contains all the behaviour you need. We also noted that you can mix more than one template into an object, or forward/delegate methods to more than one provider.

There is a many-to-many relationship between objects and their providers. This is very good, because it allows us to create providers that have clear responsibilities. For example:

~~~~~~~~
var Person = {
  setName: function (first, last) {
    this._firstName = first;
    this.lastName = last;
    return this;
  }
  fullName: function () {
    return this._firstName + " " + this._lastName;
  },
  rename: function (first, last) {
    this._firstName = first;
    this._lastName = last;
    return this;
  }
};
~~~~~~~~

And:

~~~~~~~~
var IsAuthor = {
  addBook: function (name) {
    this._books.push(name);
    return this;
  },
  books: function () {
    return this._books;
  }
};
~~~~~~~~

We can mix them all into one object:

~~~~~~~~
var raganwald = extend(raganwald, Person, IsAuthor, HasChildren);
raganwald
  .setName('reginald', 'braithwaite')
  .addBook('JavaScript Spessore')
  .addBook('JavaScript Allongé');
~~~~~~~~

Did you spot the error? You can't add books to an array that doesn't exist! Let's fix that:

~~~~~~~~
var IsAuthor = {
  initialize: function () {
    this._books = [];
  },
  addBook: function (name) {
    this._books.push(name);
    return this;
  },
  books: function () {
    return this._books;
  }
};
~~~~~~~~

Now we can write:

~~~~~~~~
var raganwald = extend(raganwald, Person, IsAuthor, HasChildren);
raganwald
  .initialize()
  .setName('reginald', 'braithwaite')
  .addBook('JavaScript Spessore')
  .addBook('JavaScript Allongé');
~~~~~~~~

There's more to our author than books, of course. Let's give him a family, using the same pattern:

~~~~~~~~
var HasChildren = {
  initialize: function () {
    this._children = [];
  },
  addChild: function (name) {
    this._children.push(name);
    return this;
  },
  numberOfChildren: function () {
    return this._children.length;
  }
};
~~~~~~~~

And the we write:

~~~~~~~~
var raganwald = extend(raganwald, Person, IsAuthor, HasChildren);
raganwald
  .initialize()
  .setName('reginald', 'braithwaite')
  .addBook('JavaScript Spessore')
  .addBook('JavaScript Allongé')
  .addChild('Thomas')
  .addChild('Clara');
~~~~~~~~

Or do we?

### conflicts

As you can see, both `IsAuthor` and `HasChildren` provide an `initialize` method. Revisiting `extend`, we see that when you extend an object, properties get copied in from the provider using assignment. This creates a property if none existed, but it overwrites a property that may already have been there.

(The same is true for our Private Mixin, Forward, and Delegation patterns.)

We see in this example the two weaknesses that our simple mixins have:

1. Simple mixins do not have any provision for initialization you have to do that yourself, and;
2. Simple mixins have a simple mechanism for resolving conflicts: The last method mixed in overwrites the previous method of the same name.

"Overwriting" is rarely the correct policy. Fortunately, we can do better.