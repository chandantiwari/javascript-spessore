{
  "author": {
    "name": "Reg Braithwaite",
    "email": "raganwald@gmail.com",
    "url": "http://braythwayt.com"
  },
  "name": "allong.es",
  "description": "Combinators and Function Decorators",
  "version": "0.14.0",
  "homepage": "http://allong.es",
  "repository": {
    "type": "git",
    "url": "git://github.com/raganwald/allong.es.git"
  },
  "main": "lib/allong.es.js",
  "scripts": {
    "test": "jasmine-node --coffee --verbose spec"
  },
  "engines": {
    "node": ""
  },
  "dependencies": {
    "promise": ""
  },
  "devDependencies": {
    "jasmine-node": "",
    "coffee-script": "",
    "grunt": "~0.4.1",
    "grunt-contrib-uglify": "~0.2.0"
  },
  "readme": "# `allong.es`\n\nThe `allong.es` library is a collection of functions designed to facilitate writing JavaScript and/or CoffeeScript with functions as first-class values. The emphasis in `allong.es` is on composing and decomposing functions using combinators and decorators. `allong.es` is designed to complement libraries like [Underscore](http://underscorejs.org), not compete with them.\n\n## Currying and Partial Application\n\nAt the heart of `allong.es` are the functions that curry and partially apply other functions. The two most important to understand are `call` and `apply`. They work very much like the `.call` and `.apply` methods that every JavaScript function implements:\n\n```javascript\nfunction greet (how, whom) {\n  return '' + how + ', ' + whom + '!';\n};\n  \ncall(greet, 'Hello', 'Tom')\n  //=> 'Hello, Tom!'\n  \napply(greet, ['Hello', 'Tom'])\n  //=> 'Hello, Tom!'\n```\n\nTheir \"special sauce\" is that they automatically *curry* the supplied function, so if you provide fewer or no arguments, you get back a partially applied or curried function:\n\n```javascript\ncall(greet)('Hello')('Tom')\n  //=> 'Hello, Tom!'\n  \ncall(greet, 'Hello')('Tom'])\n  //=> 'Hello, Tom!'\n  \napply(greet, [])('Hello')('Tom')\n  //=> 'Hello, Tom!'\n  \napply(greet, ['Hello'])('Tom'])\n  //=> 'Hello, Tom!'\n```\n\n### immediate application\n\nIf you don't want the currying/partial application behaviour, there is an immediate application version named (appropriately), `callNow` (and also another named `applyNow`, not shown):\n\n```javascript\ncallNow(greet, 'Hello', 'Tom')\n  //=> 'Hello, Tom!'\n  \ncallNow(greet, 'Hello')\n  //=> 'Hello, undefined!'\n```\n\n### variations on the order of applying the arguments\n\n`callRight` applies any arguments supplied to the right. If you supply all the arguments, it's the same as `call`, but if you supply fewer arguments, you get a right partial application:\n\n```javascript\ncallRight(greet, 'Hello', 'Tom')\n  //=> 'Hello, Tom!'\n  \ncallRight(greet, 'Hello')('Tom')\n  //=> 'Tom, Hello!'\n```\n\n`callFlipped` applies the arguments backwards, even when curried:\n\n```javascript\ncallFlipped(greet, 'Hello', 'Tom')\n  //=> 'Tom, Hello!'\n  \ncallFlipped(greet, 'Hello')('Tom')\n  //=> 'Tom, Hello!'\n  \ncallFlipped(greet)('Hello')('Tom')\n  //=> 'Tom, Hello!'\n```\n\n### more partial application\n\n`callLeft` is actually synonymous with `call`: It applies arguments given to the left. We've seen `callRight` above. Both are *variadic*: You can supply as many arguments as you want.\n\n`callFirst` and `callLast` are just like `callLeft` and `callRight`, but they are *binary* functions: They accept a function and exactly one argument. This is sometimes useful when combining functions together.\n\n`callFirst` and `callLast` both have \"flipped and curried\" versions (`callFirstWith` and `callLastWith`). `callLastWith` is especially useful for working with functions written in \"collection - operation\" style. Here we take advantage of the fact that they are \"automatically curried\" to implement the popular `pluck` function.\n\n### currying\n\n`allong.es` does support the `curry` function, it is implemented as the unary form of `call`:\n\n```javascript\nvar curry = unary(call);\n```\n\n### with\n\n`splat` was present in earlier versions of `allong.es` but has been deprecated as being too cryptic. Instead, there is a general naming convention that works as follows. Many binary functions such as `map` and `filter` are historically written to take a noun or collection as the first argument and a verb as the second.\n\nHowever, reversing and currying these functions is super-useful as it makes composeable functions out of them. That's why `callFlipped` is so important. But to save you the trouble of writing `callFlipped map` everywhere, many such functions in `allong.es` have a clipped version pre-defined and named with the suffix `With`:\n\n```\nmap(list, function)       <=> mapWith(function, list)\nfilter(list, function)    <=> filterWith(function, list)\nget(object, propertyName) <=> getWith(propertyName, object)\npluck(list, propertyName) <=> pluckWith(propertyName, list)\n```\n\nSo you \"map\" a list, but \"mapWith\" a function. And of course, they are all curried. For example:\n\n```\nmap(list)(function)       <=> mapWith(function)(list)\ndeepMap(list)(function)   <=> deepMapWith(function)(list)\nfilter(list)(function)    <=> filterWith(function)(list)\nget(object)(propertyName) <=> getWith(propertyName)(object)\npluck(list)(propertyName) <=> pluckWith(propertyName)(list)\n```\n\nThus if you have a collection such as:\n\n```javascript\nvar users = [\n  { name: 'Huey' },\n  { name: 'Dewey' },\n  { name: 'Louie' }\n]\n```\n\nYou can get the names with either:\n\n```javascript\npluck(users, 'name')\n  //=> ['Huey', 'Dewey', 'Louie']\n```\n\nOr:\n\n```javascript\npluckWith('name', users)\n  //=> ['Huey', 'Dewey', 'Louie']\n```\n\nThe latter is interesting because `pluck` and `pluckWith` are both automatically curried (like almost everything that isn't named \"now\"). Thus, we could also write:\n\n```javascript\nvar namesOf = pluckWith('name');\n\n// ...\nnamesOf(users)\n  //=> ['Huey', 'Dewey', 'Louie']\n```\n\n## Arity Function Decorators\n\n### variadic\n\nMakes a function into a variadic (accepts any number of arguments). The last named parameter will be given an array of arguments.\n\n```javascript\nvar variadic = require('allong.es').allong.es.variadic;\n\nvar fn = variadic(function (a) { return a })\n\nfn()\n  //=> []\nfn(1, 2, 3)\n  //=> [1,2,3]\n\nfn = variadic(function (a,b) { return { a: a, b: b } })\n\nfn()\n  //=> { a: undefined, b: [] }\nfn(1)\n  //=> { a: 1, b: [] }\nfn(1,2,3)\n  //=> { a: 1, b: [2, 3] }\n```\n\n### variadic, part ii\n\nWhen given just the function, `variadic` returns a function with an arity of zero. This is consistent with JavaScript programming practice. There are times when you wish to report an arity, meaning that you want the returned function to have its `length` getibute set.\n\nYou do this by prefacing the function argument with a length:\n\n```javascript\nfn = variadic(function (a,b) { return { a: a, b: b } });\n\nfn.length\n  //=> 0\n  \nfn2 = variadic(1, function (a,b) { return { a: a, b: b } }); \n\nfn2.length\n  //=> 1\n```\n\n### unary, binary, and ternary\n\nSometimes, you have a function that takes multiple arguments, but you only want it to accept one, or two, or maybe three arguments and ignore the rest. For example, `parseInt` takes a radix as an optional second parameter. And that is havoc if you try to use it with `Array.map`:\n\n```javascript\n['1', '2', '3', '4', '5'].map(parseInt)\n  //=> [ 1,\n  //     NaN,\n  //     NaN,\n  //     NaN,\n  //     NaN ]\n```\n\nUse `unary(parseInt)` to solve the problem:\n\n```javascript\n['1', '2', '3', '4', '5'].map(unary(parseInt))\n  //=> [ 1, 2, 3, 4, 5 ]\n```\n\n`binary` has similar uses when working with `Array.reduce` and its habit of passing three parameters to your supplied function.\n\n## Miscellaneous Combinators\n\n### bound\n\n```javascript\nvar bound = require('allong.es').allong.es.bound;\n    \nbound(fn, args...)(obj)\n  //=> fn.bind(obj, args...)\n```\n\n### getWith\n\n```javascript\nvar getWith = require('allong.es').allong.es.getWith;\n    \narray.map(getWith('property'))\n  //=> array.map(function (element) {\n  //               return element['property']\n  //             })\n```\n\n## Functional Composition\n\n```javascript\nvar compose = require('allong.es').allong.es.compose,\n    sequence = require('allong.es').allong.es.sequence;\n    \ncompose(a, b, c)\n  //=> function (x) {\n  //     return a(b(c(x)))\n  //   }\n \nsequence(a, b, c)\n  //=> function (x) {\n  //     return c(b(a(x)))\n  //   }\n```\n\n## List Combinators\n\n### mapWith and deepMapWith\n\n```javascript\nvar mapWith = require('allong.es').allong.es.mapWith,\n    deepMapWith = require('allong.es').allong.es.deepMapWith;\n    \nvar squareList = mapWith(function (x) { return x * x })\n\nsquareList([1, 2, 3, 4])\n  //=> [1, 4, 9, 16]\n  \nvar squareTree = deepMapWith(function (x) { return x * x })\n\nsquareTree([1, 2, [3, 4]])\n  //=> [1, 4, [9, 16]]\n```\n\n## Function/Method Decorators\n\n### maybe\n\n```javascript\nvar maybe = require('allong.es').allong.es.maybe;\n    \nvar safeFirst = maybe(function (arr) { return arr[0] })\n\nsafeFirst([1, 2, 3])\n  //=> 1\nsafeFirst(null)\n  //=> null\n```\n\n### tap\n\n```javascript\nvar tap = require('allong.es').allong.es.tap;\n    \ntap([1, 2, 3, 4, 5], send('pop'))\n  //=> [1, 2, 3, 4]\n```\n\n### fluent\n\n```javascript\nvar fluent = require('allong.es').allong.es.fluent;\n    \nRole = function () {}\n\nRole.prototype.set = fluent( function (property, name) { \n  this[property] = name \n})\n\nvar doomed = new Role()\n  .set('name', \"Fredo\")\n  .set('relationship', 'brother')\n  .set('parts', ['I', 'II'])\n```\n\n### once\n\n```javascript\nvar once = require('allong.es').allong.es.once;\n    \nvar message = once( function () { console.log(\"Hello, it's me\") })\n\nmessage()\n  //=> \"Hello, it's me\"\nmessage()\n  //=>\nmessage()\n  //=>\nmessage()\n  //=>\n```\n\n## Decorating Classes/Constructors\n\n```javascript\nvar mixin = require('allong.es').allong.es.mixin,\n    classDecorator = require('allong.es').allong.es.classDecorator;\n    \nfunction Todo (name) {\n  var self = this instanceof Todo\n             ? this\n             : new Todo();\n  self.name = name || 'Untitled';\n  self.done = false;\n};\n\nTodo.prototype.do = fluent( function () {\n  this.done = true;\n});\n\nTodo.prototype.undo = fluent( function () {\n  this.done = false;\n});\n\nvar AddLocation = mixin({\n      setLocation: fluent( function (location) {\n        this.location = location;\n      }),\n      getLocation: function () { return this.location; }\n    });\n\nAddLocation.call(Todo.prototype);\n// Or use AddLocation(Todo.prototype)\n\nnew Todo(\"Vacuum\").setLocation('Home');\n  //=> { name: 'Vacuum',\n  //     done: false,\n  //     location: 'Home' }\n\nvar AndColourCoded = classDecorator({\n  setColourRGB: fluent( function (r, g, b) {\n    this.colourCode = { r: r, g: g, b: b };\n  }),\n  getColourRGB: function () {\n    return this.colourCode;\n  }\n});\n\nvar ColourTodo = AndColourCoded(Todo);\n\nnew ColourTodo('Use More Decorators').setColourRGB(0, 255, 0);\n  //=> { name: 'Use More Decorators',\n  //     done: false,\n  //     colourCode: { r: 0, g: 255, b: 0 } }\n```\n\nNote: `classDecorator` works with JavaScript constructors that have a default implementation (they work properly with no arguments), and are new-agnostic (they can be called with new or as a normal function). `Todo` above has both properties.\n\n## Functional Iterators\n\nFunctional iterators are stateful functions that \"iterate over\" the values in some ordered data set. You call the iterator repeatedly to obtain the values, and it will either never stop returning values (an infinite data set) or return `undefined` when there are no more values to return.\n\nThe functional iterators utilities are all namespaced:\n\n```javascript\nvar iterators = require('allong.es').allong.es.iterators;\n```\n\n### FlatArrayIterator and RecursiveArrayIterator\n\nMaking functional iterators from arrays:\n\n```javascript\nvar FlatArrayIterator = iterators.FlatArrayIterator,\n    RecursiveArrayIterator = iterators.RecursiveArrayIterator;\n    \nvar i = FlatArrayIterator([1, 2, 3, 4, 5]);\n\ni();\n  //=> 1\ni();\n  //=> 2\ni();\n  //=> 3\ni();\n  //=> 4\ni();\n  //=> 5\ni();\n  //=> undefined\n    \nvar i = FlatArrayIterator([1, [2, 3, 4], 5]);\n\ni();\n  //=> 1\ni();\n  //=> [2, 3, 4]\ni();\n  //=> 5\ni();\n  //=> undefined\n    \nvar i = RecursiveArrayIterator([1, [2, 3, 4], 5]);\n\ni();\n  //=> 1\ni();\n  //=> 2\ni();\n  //=> 3\ni();\n  //=> 4\ni();\n  //=> 5\ni();\n  //=> undefined\n```\n\n### range and numbers\n\n```javascript\nvar range = iterators.range,\n    numbers = iterators.numbers;\n\nvar i = range(1, 5);\n\ni();\n  //=> 1\ni();\n  //=> 2\ni();\n  //=> 3\ni();\n  //=> 4\ni();\n  //=> 5\ni();\n  //=> undefined\n\nvar i = range(1, 5, 2);\n\ni();\n  //=> 1\ni();\n  //=> 3\ni();\n  //=> 5\ni();\n  //=> undefined\n\nvar i = range(5, 1);\n\ni();\n  //=> 5\ni();\n  //=> 4\ni();\n  //=> 3\ni();\n  //=> 2\ni();\n  //=> 1\ni();\n  //=> undefined\n\nvar i = range(1);\n\ni();\n  //=> 1\ni();\n  //=> 2\ni();\n  //=> 3\n// ...\n\nvar i = numbers();\n\ni();\n  //=> 1\ni();\n  //=> 2\ni();\n  //=> 3\n// ...\n\nvar i = numbers(0);\n\ni();\n  //=> 0\ni();\n  //=> 1\ni();\n  //=> 2\ni();\n  //=> 3\n// ...\n```\n\n### unfold and unfoldWithReturn\n\nUnfold makes an iterator out of a seed by successively applying a function to the seed value. Here's an example duplicating the \"numbers\" feature:\n\n```javascript\nvar unfold = iterators.unfold,\n    unfoldWithReturn = iterators.unfoldWithReturn;\n    \nvar i = unfold(1, function (n) { return n + 1; });\n\ni();\n  //=> 1\ni();\n  //=> 2\ni();\n  //=> 3\n// ...\n    \nvar i = unfoldWithReturn(1, function (n) { \n  return [n + 1, n + n]; \n});\n\ni();\n  //=> 2\ni();\n  //=> 4\ni();\n  //=> 6\n// ...\n```\n\nA richer example of `unfoldWithReturn`:\n\n```javaascript\nvar cards = ['A', 2, 3, 4, 5, 6, 7, 8, 9, '10', 'J', 'Q', 'K'];\n\nfunction pickCard (deck) {\n  var position;\n  \n  if (deck.length === 0) {\n    return [[], void 0];\n  }\n  else {\n    position = Math.floor(Math.random() * deck.length);\n    return [\n      deck.slice(0, position).concat(deck.slice(position + 1)),\n      deck[position]\n    ];\n  }\n};\n\nvar i = unfoldWithReturn(cards, pickCard);\n\ni();\n  //=> 5\ni();\n  //=> 4\ni();\n  //=> 2\ni();\n  //=> J\n  \n// ...\n```\n\n### map\n\nStateless mapping of an iterator to another iterator:\n\n```javascript\nvar map = iterators.map;\n    \nvar squares = map(numbers, function (n) { return n * n; });\n\nsquares();\n  //=> 1\nsquares();\n  //=> 4\nsquares();\n  //=> 9\n// ...\n```\n\n### accumulate\n\nAccumulating an iterator to another iterator, a/k/a stateful mapping, with an optional seed:\n\n```javascript\nvar accumulate = iterators.accumulate;\n    \nvar runningTotal = accumulate(numbers, function (accumulation, n) { \n      return accumulation + n; \n    });\n\nrunningTotal();\n  //=> 1\nrunningTotal();\n  //=> 3\nrunningTotal();\n  //=> 6\nrunningTotal();\n  //=> 10\nrunningTotal();\n  //=> 15\n// ...\n\nvar runningTotal = accumulate(numbers, function (accumulation, n) { \n      return accumulation + n; \n    }, 5);\n\nrunningTotal();\n  //=> 6\nrunningTotal();\n  //=> 8\nrunningTotal();\n  //=> 11\nrunningTotal();\n  //=> 15\nrunningTotal();\n  //=> 20\n// ...\n```\n\n### accumulateWithReturn\n\nThis code transforms filters duplicates out of an iterator of numbers by turning them into \"false.\" It consumes space proportional to the time it runs and the size of the set of possible numbers in its iterator.\n\n```javascript\nvar accumulateWithReturn = iterators.accumulateWithReturn;\n    \nvar randomNumbers = function () {\n  return Math.floor(Math.random() * 10);\n};\n\nrandomNumbers();\n  //=> 7\nrandomNumbers();\n  //=> 0\nrandomNumbers();\n  //=> 1\nrandomNumbers();\n  //=> 1\nrandomNumbers();\n  //=> 6\n// ...\n\nvar uniques = accumulateWithReturn(randomNumbers, function (alreadySeen, number) {\n  var key = number.toString();\n  \n  if (alreadySeen[key]) {\n    return [alreadySeen, false];\n  }\n  else {\n    alreadySeen[key] = true;\n    return [alreadySeen, number];\n  }\n}, {});\n\nuniques();\n  //=> 7\nuniques();\n  //=> 5\nuniques();\n  //=> 1\nuniques();\n  //=> false\nuniques();\n  //=> 9\nuniques();\n  //=> 4\nuniques();\n  //=> false\n// ...\n```\n\n### select and reject\n\n```javascript\nvar select = iterators.select,\n    reject = iterators.reject;\n\nfunction isEven (number) {\n  return number === 0 || !isEven(number - 1);\n};\n\nvar evens = select(randomNumbers, isEven);\n\nevens();\n  //=> 0\nevens();\n  //=> 6\nevens();\n  //=> 0\nevens();\n  //=> 2\nevens();\n  //=> 4\n// ...\n\nvar odds = reject(randomNumbers, isEven);\n\nodds();\n  //=> 3\nodds();\n  //=> 1\nodds();\n  //=> 7\nodds();\n  //=> 9\nodds();\n  //=> 9\n// ...\n```\n\nNote: `select` and `reject` will enter an \"infinite loop\" if the iterator does not terminate and also does not have any elements matching the condition.\n\n### slice\n\n```javascript\nvar slice = iterators.slice,\n    numbers = unfold(1, function (n) { return n + 1; });\n\nvar i = slice(numbers, 3);\n\ni();\n  //=> 4\ni();\n  //=> 5\ni();\n  //=> 6\n\ni = slice(numbers, 3, 2);\n\ni();\n  //=> 10\ni();\n  //=> 11\ni();\n  //=> undefined\n```\n\n### take\n\n```javascript\nvar take = iterators.take,\n    numbers = unfold(1, function (n) { return n + 1; });\n\nvar i = take(numbers);\n\ni();\n  //=> 1\ni();\n  //=> undefined\n\nvar i = take(numbers);\n\ni();\n  //=> 2\ni();\n  //=> undefined\n\nvar i = take(numbers, 3);\n\ni();\n  //=> 3\ni();\n  //=> 4\ni();\n  //=> 5\ni();\n  //=> undefined\n// ...\n```\n\n### drop\n\n```javascript\nvar drop = iterators.drop,\n    numbers = unfold(1, function (n) { return n + 1; });\n\ndrop(numbers);\n\nnumbers();\n  //=> 2\nnumbers();\n  //=> 3\nnumbers();\n  //=> 4\n\ndrop(numbers);\n\nnumbers();\n  //=> 6\nnumbers();\n  //=> 7\n\ndrop(numbers, 3);\n\nnumbers();\n  //=> 11\nnumbers();\n  //=> 12\n// ...\n```\n\n## Trampolining\n\n```\nvar trampoline = require('allong.es').allong.es.trampoline,\n    tailCall = require('allong.es').allong.es.tailCall;\n    \nfunction factorial (n) {\n  var _factorial = trampoline( function myself (acc, n) {\n    return n > 0\n      ? tailCall(myself, acc * n, n - 1)\n      : acc\n  });\n  \n  return _factorial(1, n);\n};\n\nfactorial(10);\n  //=> 3628800\n```\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/raganwald/allong.es/issues"
  },
  "_id": "allong.es@0.14.0",
  "_from": "allong.es@"
}
